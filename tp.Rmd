---
title: "TP génération de nombres aléatoires et probabilités"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(randtoolbox)
source('generateur.R')
source('tests.R')
source('files.R')
source('lois.R')
```

# Question 2

```{r include=FALSE}
k <- 1000
seed <- 13813817
```

## 2.1

Pour VonNeumann, la répartition est très mauvaise et pas visiblement uniforme. 
Les autres générateurs ont l'air d'être 
```{r}
breaks = 10
rep <- VonNeumann(k, 1, seed) / (9999)
hist(rep, main = "Répartition uniforme avec VonNeumann", breaks = breaks)

rep <- randu(k, seed) / (2^31 - 1)
hist(rep, main = "Répartition uniforme avec RANDU", breaks = breaks)

rep <- std_minimal(k, seed) / (2^31 - 2)
hist(rep, main = "Répartition uniforme avec Standard Minimal", breaks = breaks)

rep <- MersenneTwister(k, 1, seed) / (2^32 - 1)
hist(rep, main = "Répartition uniforme avec MersenneTwister", breaks = breaks)

breaks = 30
rep <- VonNeumann(k, 1, seed) / (9999)
hist(rep, main = "Répartition uniforme avec VonNeumann", breaks = breaks)

rep <- randu(k, seed) / (2^31 - 1)
hist(rep, main = "Répartition uniforme avec RANDU", breaks = breaks)

rep <- std_minimal(k, seed) / (2^31 - 2)
hist(rep, main = "Répartition uniforme avec Standard Minimal", breaks = breaks)

rep <- MersenneTwister(k, 1, seed) / (2^32 - 1)
hist(rep, main = "Répartition uniforme avec MersenneTwister", breaks = breaks)
```

Pour VonNeumann, on remarque les points sont peu étalés
Pour les autres, on ne peut a priori pas   (et donc aléatoire) :
```{r}
rep <- VonNeumann(k, 1, seed)
plot(rep[1:k-1], rep[2:k])

rep <- randu(k, seed)
plot(rep[1:k-1], rep[2:k])

rep <- std_minimal(k, seed)
plot(rep[1:k-1], rep[2:k])

rep <- MersenneTwister(k, 1, seed)
plot(rep[1:k-1], rep[2:k])
```

# Question 3

Pour VonNeumann et RANDU, on observe pour la plupart des tests que la p valeur est en dessous des 1 %.

Pour Standard Minimal et MersenneTwister, on observe très peu de p valeurs inférieures à 1 %.

Ainsi, RANDU et VonNeumann ne passe le premier test et n'est donc pas un bon générateur aléatoire.

Pour Standard Minimal et MersenneTwister, on ne peut rien conclure pour l'instant.
```{r}
nb_seed <- 100
seed <- sample.int(2^31, nb_seed)
ShowTestResults <- function(frequence)
{
  nb_reussis <- PercentageTest(frequence, 0.01) 
  percentage <- nb_reussis / nb_seed
  plot(frequence, xlim = c(0, 100), ylim = c(0, 1.0))
  abline(h = 0.01, col = "red")
  mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)
  pie(c(percentage, 1 - percentage), labels = c(nb_reussis, nb_seed - nb_reussis), col = c("green", "red"))
  legend("topright", c(">= 0.01", "< 0.01"), cex = 0.8, fill = c("green", "red"))
}
```

```{r}
frequence <- sapply(seed, function(s) Frequency(VonNeumann(k, 1, s), 14))
ShowTestResults(frequence)

frequence <- sapply(seed, function(s) Frequency(randu(k, s), 31))
ShowTestResults(frequence)

frequence <- sapply(seed, function(s) Frequency(std_minimal(k, s), 31))
ShowTestResults(frequence)

frequence <- sapply(seed, function(s) Frequency(MersenneTwister(k, 1, s), 32))
ShowTestResults(frequence)
```

# Question 4
Pour VonNeumann et RANDU, on observe pour la plupart des tests que la p valeur est en dessous des 1 %.

Pour Standard Minimal et MersenneTwister, on observe très peu de p valeurs inférieures à 1 %.

Ainsi, RANDU et VonNeumann ne passe le premier test et n'est donc pas un bon générateur aléatoire.

Pour Standard Minimal et MersenneTwister, on ne peut rien conclure pour l'instant.
```{r}
frequence <- sapply(seed, function(s) Runs(VonNeumann(k, 1, s), 14))
ShowTestResults(frequence)

frequence <- sapply(seed, function(s) Runs(randu(k, s), 31))
ShowTestResults(frequence)

frequence <- sapply(seed, function(s) Runs(std_minimal(k, s), 31))
ShowTestResults(frequence)

frequence <- sapply(seed, function(s) Runs(MersenneTwister(k, 1, s), 32))
ShowTestResults(frequence)

```

# Question 5

```{r}
frequence <- sapply(seed, function(s) order.test(as.vector(VonNeumann(k, 1, s)), d = 4, echo=FALSE)$p.value)
ShowTestResults(frequence)

frequence <- sapply(seed, function(s) order.test(randu(k, s), d = 4, echo=FALSE)$p.value)
ShowTestResults(frequence)

frequence <- sapply(seed, function(s) order.test(std_minimal(k, s), d = 4, echo=FALSE)$p.value)
ShowTestResults(frequence)

frequence <- sapply(seed, function(s) order.test(as.vector(MersenneTwister(k, 1, s)), d = 4, echo=FALSE)$p.value)
ShowTestResults(frequence)

```

# Question 7

```{r}
taux_arrivees = 6
taux_departs = 10
duree = 12

file = FileMM1(taux_arrivees/60, taux_departs/60, duree*60)
evolution = EvolutionFileMM1(file$arrivees, file$departs, duree*60)
plot(x=evolution$dates, y=evolution$nombres, type="l")

taux_arrivees = 8
file = FileMM1(taux_arrivees/60, taux_departs/60, duree*60)
evolution = EvolutionFileMM1(file$arrivees, file$departs, duree*60)
plot(x=evolution$dates, y=evolution$nombres, type="l")

taux_arrivees = 10
file = FileMM1(taux_arrivees/60, taux_departs/60, duree*60)
evolution = EvolutionFileMM1(file$arrivees, file$departs, duree*60)
plot(x=evolution$dates, y=evolution$nombres, type="l")

taux_arrivees = 14
file = FileMM1(taux_arrivees/60, taux_departs/60, duree*60)
evolution = EvolutionFileMM1(file$arrivees, file$departs, duree*60)
plot(x=evolution$dates, y=evolution$nombres, type="l")
```
Les résultats montre que plus on augmente la fréquence d'arrivées, moins la file d'attente a de chances de se vider.

# Question 8
```{r}
VerificationFormuleLittle <- function(taux_arrivees, taux_departs, duree)
{
  iterations <- 100
  means <- vector(length=iterations)
  temps_moyens <- vector(length=iterations)
  lambda <- taux_arrivees
  mu <- taux_departs
  for (i in 1:iterations)
  {
    file = FileMM1(lambda, mu, duree)
    evolution = EvolutionFileMM1(file$arrivees, file$departs, duree)
    # plot(x=evolution$dates, y=evolution$nombres, type="l")
    means[i] <- weighted.mean(evolution$nombres, evolution$durees)
    temps_moyens[i] <- mean(file$temps_attente_moyen)
  }
  
  cat(paste("Taux d'arrivees = ", taux_arrivees, "/h, Taux de départs = ", taux_departs, "/h, Durée = ", duree, "h\n"))
  # plot(means, type="p")
  cat(paste("Nombre moyen de personnes sur le serveur (moyenne sur", iterations ,"itérations) = ", mean(means), "\n"))
  cat(paste("Nombre moyen de personnes sur le serveur (théorique) = ", MoyenneTheoriqueN(taux_arrivees, taux_departs), "\n"))
  
  # plot(temps_moyens, type="p")
  cat(paste("Temps d'attente moyen sur le serveur (moyenne sur", iterations ,"itérations) = ", mean(temps_moyens), "h \n"))
  cat(paste("Temps d'attente moyen sur le serveur (théorique) = ", MoyenneTheoriqueW(taux_arrivees, taux_departs, lambda), "h \n"))
  cat("\n")
}


for (taux_arrivees in c(6, 8, 10, 14))
{
  VerificationFormuleLittle(taux_arrivees, 10, 100)
}


```

# Question Bonus 1

```{r}
nb_iterations <- 1000
realisations <- vector(length = nb_iterations)
n <- 20
p <- 0.5
for (i in 1:nb_iterations)
{
  realisations[i] <- LoiBinomiale(n, p)
}
plot(table(realisations), col = "red")

# par(new = TRUE)
xseq<-seq(0,n,0.01)
densities<-dnorm(xseq, n*p, n*p*(1-p))
plot(xseq, densities, col = "blue", type="l")
```
# Question Bonus 2

```{r}
nb_iterations <- 100000
microbenchmark::microbenchmark(times=nb_iterations,LoiBonusInversion(), LoiBonusRejet())
realInversion <- vector(length = nb_iterations)
realRejet <- vector(length = nb_iterations)
for (i in 1:nb_iterations)
{
  realInversion[i] <- LoiBonusInversion()
  realRejet[i] <- LoiBonusRejet()
}
mean(realInversion)
mean(realRejet)
hist(realInversion, ylim = c(0, 8000))
hist(realRejet, ylim = c(0, 8000))


```