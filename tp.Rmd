---
title: "TP génération de nombres aléatoires et probabilités"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(randtoolbox)
source('generateur.R')
source('tests.R')
source('files.R')
```

# Question 2

```{r include=FALSE}
k <- 1000
seed <- 13813817
```

## 2.1

On remarque en réduisant la taille des cellules de l'histogramme que la répartition n'est pas si homogène 
```{r}
rep <- randu(k, seed)
hist(rep, main = "Répartition uniforme avec RANDU", breaks = 10)

rep <- std_minimal(k, seed)
hist(rep, main = "Répartition uniforme avec Standard Minimal", breaks = 10)

rep <- randu(k, seed)
hist(rep, main = "Répartition uniforme avec RANDU", breaks = 50)

rep <- std_minimal(k, seed)
hist(rep, main = "Répartition uniforme avec Standard Minimal", breaks = 50)
```

On remarque que la génération des nombres n'est pas uniforme mais qu'elle n'est pas prévisible (et donc aléatoire) :
```{r}
rep <- randu(k, seed)
plot(rep[1:k-1], rep[2:k])

rep <- std_minimal(k, seed)
plot(rep[1:k-1], rep[2:k])
```

# Question 3

Pour RANDU, on observe pour la plupart des tests que la p valeur est en dessous des 1 %.

Pour Standard Minimal, on observe très peu de p valeurs inférieures à 1 %.

Ainsi, RANDU ne passe le premier test et n'est donc pas un bon générateur aléatoire.

Pour Standard Minimal, on ne peut rien conclure pour l'instant.
```{r}
nb_seed <- 100
seed <- sample.int(2^31, nb_seed)
```

```{r}
frequence <- sapply(seed, function(s) Frequency(randu(k, s), 31))
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)

frequence <- sapply(seed, function(s) Frequency(std_minimal(k, s), 31))
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)

frequence <- sapply(seed, function(s) Frequency(MersenneTwister(k, 1, s), 32))
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)

frequence <- sapply(seed, function(s) Frequency(VonNeumann(k, 1, s), 14))
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)

```

# Question 4
Pour RANDU, on observe pour la plupart des tests que la p valeur est en dessous des 1 %.

Pour Standard Minimal, on observe très peu de p valeurs inférieures à 1 %.

Ainsi, RANDU ne passe le premier test et n'est donc pas un bon générateur aléatoire.

Pour Standard Minimal, on ne peut rien conclure pour l'instant.
```{r}
frequence <- sapply(seed, function(s) Runs(randu(k, s), 31))
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)

frequence <- sapply(seed, function(s) Runs(std_minimal(k, s), 31))
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)

frequence <- sapply(seed, function(s) Runs(MersenneTwister(k, 1, s), 32))
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)

frequence <- sapply(seed, function(s) Runs(VonNeumann(k, 1, s), 14))
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)
```

# Question 5

```{r}
frequence <- sapply(seed, function(s) order.test(randu(k, s), d = 4, echo=FALSE)$p.value)
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)

frequence <- sapply(seed, function(s) order.test(std_minimal(k, s), d = 4, echo=FALSE)$p.value)
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)

frequence <- sapply(seed, function(s) order.test(as.vector(VonNeumann(k, 1, s)), d = 4, echo=FALSE)$p.value)
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)

frequence <- sapply(seed, function(s) order.test(as.vector(MersenneTwister(k, 1, s)), d = 4, echo=FALSE)$p.value)
plot(frequence)
abline(h = 0.01, col = "red")
percentage <- PercentageTest(frequence, 0.01) / nb_seed
mtext(paste("Proportion de tests réussis : ", percentage * 100, " %"), side = 3)

```

# Question 7

```{r}
taux_arrivees = 6
taux_departs = 10
duree = 12

file = FileMM1(taux_arrivees/60, taux_departs/60, duree*60)
evolution = EvolutionFileMM1(file$arrivees, file$departs, duree*60)
plot(x=evolution$dates, y=evolution$nombres, type="l")
mean(evolution$nombres)

taux_arrivees = 8
file = FileMM1(taux_arrivees/60, taux_departs/60, duree*60)
evolution = EvolutionFileMM1(file$arrivees, file$departs, duree*60)
plot(x=evolution$dates, y=evolution$nombres, type="l")

taux_arrivees = 10
file = FileMM1(taux_arrivees/60, taux_departs/60, duree*60)
evolution = EvolutionFileMM1(file$arrivees, file$departs, duree*60)
plot(x=evolution$dates, y=evolution$nombres, type="l")

taux_arrivees = 14
file = FileMM1(taux_arrivees/60, taux_departs/60, duree*60)
evolution = EvolutionFileMM1(file$arrivees, file$departs, duree*60)
plot(x=evolution$dates, y=evolution$nombres, type="l")
```
Les résultats montre que plus on augmente la fréquence d'arrivées, moins la file d'attente a de chances de se vider.

# Question 8
```{r}
iterations <- 1000
means <- vector(length=iterations)

taux_arrivees = 6
taux_departs = 10
duree = 12
for (i in 1:iterations)
{
  file = FileMM1(taux_arrivees/60, taux_departs/60, duree*60)
  evolution = EvolutionFileMM1(file$arrivees, file$departs, duree*60)
  # plot(x=evolution$dates, y=evolution$nombres, type="l")
  means[i] <- weighted.mean(evolution$nombres, evolution$durees)
}
print(mean(means))
```